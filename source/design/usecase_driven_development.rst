ユースケース駆動開発
===========================================================

.. contents:: 目次
   :depth: 1
   :local:

1. 要求定義 : ドメインモデリング
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- プロジェクトの用語集 / 辞書を作成する

- 異なるクラス（ドメインオブジェクト）の関係を線で示したクラス図

    - 汎化 : is-a
    - 集約 : has-a

- プロジェクトのメンバー全員が、明確な用語で問題領域を明確に理解する
- 以降のプロセスは、オブジェクトモデルの用語を用いてコミュニケーションを取る

[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ユーザストーリ

    - ユーザストーリから、名詞や名詞句を抽出する
    - **アクター** は、 **〇〇する** ため、 **〇〇しなければならない**

[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ドメインモデル例

.. mermaid:: 

    classDiagram

        マスター書籍カタログ
        書籍カタログ
        書籍
        顧客評価
        カテゴリ
        価格
        取扱品目

        書籍レビュ
        編集者レビュ
        読者レビュ

        マスター書籍カタログ o-- 書籍カタログ
        書籍カタログ o-- 書籍
        書籍 o-- 顧客評価
        書籍 o-- カテゴリ
        書籍 o-- 価格
        書籍 o-- 書籍レビュ
        取扱品目 o-- 書籍
        取扱品目 o-- 価格
        書籍レビュ <|-- 編集者レビュ
        書籍レビュ <|-- 読者レビュ


[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 問題領域のオブジェクトに焦点を合わせる
- オブジェクト同士の関係を表現するために、汎化(is-a)、集約(has-a)関係を利用する
- 最初のドメインモデリングのかける時間は2時間に限定する
- 問題領域中の主要な概念を中心にクラスを構成する
- ドメインモデルをデータモデルと勘違いしてはいけない
- オブジェクト（インスタンス）とデータベースのテーブルを混同しない
- 名前が曖昧になることを避けるために、ユースケースを書く前にドメインモデルを作成する
- 最終的な **クラス図** が、ドメインモデルと正確に一致することを期待しない。が相似する関係はある
- ドメインモデルには、画面やその他のGUI固有の部品クラスを配置してはいけない


2. 要求定義 : ユースケースモデリング
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ユースケース図を作成する
- ユースケース記述（基本コース/代替コース）を作成する
- ユーザのアクションとアクションに対するシステムの反応を記述する

[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ユーザストーリ
- ドメインモデル

[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ユースケース図
- ユースケース記述（基本コース/代替コース）

[基本/代替コース]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ユースケースには、以下の振る舞いが含まれていること

- 基本コース : 正常
- 代替コース : エラー

[ユースケースを書くための「3つの魔法の質問」]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1. 何が起こるか？
    - これで「晴れの日のシナリオ」の開始がわかる
2. そして何が起こるか？
    - 「晴れの日のシナリオ」が完了するまでこの質問を繰り返す
3. ほかにどのようなことが起こるか？
    - 想定可能なすべての「雨の日のシナリオ」を考える。

[ユースケース図]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[ユースケース記述 テンプレート]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. csv-table::
   :header: "項目", "説明", "備考"

   "ユースケース名", "動作を示す短い動詞句で目的のわかる名前"
   "主アクター", "主アクターのロール名 / 説明"
   "事前条件", "ユースケースが開始される前に満たされている必要のある条件", "オプション"
   "事後条件", "ユースケースが完了した後に満たされている必要のある条件", "オプション"
   "基本コース", "ユースケースの正常なフロー"
   "代替コース", "ユースケースの異常なフロー"


[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 2段階ルールに従う
- アクターとユースケース図を使ってユースケースを組織化する
- ユースケースを叙述的に書く

  - 説明文や報告書のように、感情や意見を挟まず、淡々と事実を書くこと

- イベントとその応答の流れとしてユースケースを書き、ユーザとシステムの対話の両側を記述する
- GUIプロトタイプや画面モックを使う
- ユースケースは実行時の振る舞いの仕様であることを忘れないようにする
- オブジェクトモデルの言葉を使ってユースケースを書く
- 名詞 - 名詞 - 動詞 という文の構造に従ってユースケースを書く
- ドメインクラスの名前を使う
- (画面のような)バウンダリクラスの名前を使う


3. 要求定義 : 要求レビュー
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ガイドライン に沿って、ユースケース図、ユースケース記述をレビューする

[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- クラス図
- ユースケース図
- ユースケース記述

[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- より完璧な ドメインモデル（クラス図）
- より完璧な ユースケース図
- より完璧な ユースケース記述

[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 問題領域におけるもっとも重要な概念(現実のオブジェクトなど)の少なくとも80%が、エンドユーザーにも理解できる言葉で記述されているか確認する
- ドメインモデルが、ドメインオブジェクトの間のis-a、has-a関係を正しく表現しているか確認する
- ユースケースの基本コース/代替コースの双方が叙述的に書かれていることを確認する
- 機能要求のリストがある場合、それが叙述的なユースケース記述の中に紛れていないか確認する
- ユースケースがパッケージによって組織化されていて、各パッケージには最低でも1つのユースケースが含まれていることを確認する
- ユースケースがドメインモデリングの用語で記述されていることを確認する
- ユースケースはユーザインタフェースの用語で記述されていることを確認する
- ユースケースには、GUI紙芝居、線図、画面モックを付随させる
- エンドユーザー、ステークホルダーなどの関係者と一緒にレビューする
- レビューを「より良いユースケースのための8つの簡単なステップ」に沿って構造化させる

[より良いユースケースのための8つの簡単なステップ]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- スコープ外のものをすべてを取り除く
- 指示的な記述を叙述的に変える
- ユースケース記述が、抽象的すぎないことを確認する
- 関係するドメインオブジェクトに名前をつける
- すべての代替コースが存在することを確認する
- ユースケースから、すべての要求を追跡する
- ユーザが望むことが、個々のユースケースに記述されていることを確認する


4. 分析/概念設計/アーキテクチャ : 予備設計 - ロバストネス分析
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ユースケースから詳細設計を作成するには、ユースケースをオブジェクトに関連付ける必要がある
- ロバストネス分析でそれを行う

    - ユースケース記述を分析し、ユースケースごとに最初のオブジェクト群を推定する

[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- より完璧な ドメインモデル（クラス図）
- ユースケース図
- ユースケース記述

[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ロバストネス図
- より完璧な ドメインモデル（クラス図）
- より完璧な ユースケース図
- より完璧な ユースケース記述

[ロバストネス図の構造]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ロバストネス図における動作の流れは、1ユースケース記述の中のステップと1対1の相関関係にある

**ロバストネス図に出てくるオブジェクト**

.. csv-table::
   :header: "名称", "説明", "備考"

   "バウンダリ", "プレゼンテーション層。システムと外部世界との「インターフェイス」", "名詞/UI"
   "エンティティ", "ドメインモデル上のクラス", "名詞/データ"
   "コントローラ", "バウンダリ と エンティティ の 接着剤", "動詞/処理"

**ルール**

- 名詞は、動詞とつなぐことができる（逆もまた同様）
- 名詞は、他の名詞とつなぐことはできない
- 動詞は、他の動詞とつなぐことができる
- コントローラは、システムの振る舞いを表すものであり、コントローラが記述から省かれるのは極めてまずい

.. mermaid::

    graph LR

    %% ユーザーログイン処理
    U[actor:ユーザー]

    B1[b: ログインページ]
    B2[b: マイページ]

    C1[c: ログインページを表示する]
    C2[c: IDとパスワードを入力する]
    C3[c: アカウントを参照する]
    C4[c: マイページを表示する]
   
    E1[e: User]

    U --> B1
    C1 --> B1
    B1 --> C2
    C2 -->|ボタン押下| C3
    C3 -->|参照| E1
    C3 -->|認証成功| C4
    C4 --> B2
    C3 -->|認証失敗| B1


[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ユースケース記述をロバストネス図に直接貼り付ける
- ドメインモデルからエンティティクラスを取り出し、不足しているものがあれば追加する
- ロバストネス図の作成中にも、ユースケース記述を書き直して明確にしていく
- 画面単位にバウンダリオブジェクトを作成し、明確な画面名をつける
- コントローラーは、 **本物のコントロールオブジェクト** になることがあるかもしれない。論理的なソフトウェア機能にすぎない。
- ロバストネス図上の矢印の方向について気にしてはいけない
- 親のユースケースから起動できるのであれば、ユースケースをロバストネス図上にドラッグしてもかまわない
- ロバストネス図はユースケースに対する予備的な概念設計を示す。詳細設計ではない
- **バウンダリオブジェクト** と **エンティティクラス** は、シーケンス図の中で、オブジェクトの役割を果たす
- **コントロールオブジェクト** は、シーケンス図の中で、メソッドを呼び出す役割を果たす
- ロバストネス図は、ユースケースの **オブジェクトの絵** である


5. 分析/概念設計/アーキテクチャ : 予備設計レビュー
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ロバストネス図

[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- より完璧な ロバストネス図

[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ユースケースごとに、ユースケース記述をロバストネス図が一致しているかどうかを蛍光ペンを使って確認する
- ロバストネス図上のすべてのエンティティが、更新後のドメインモデル上に確実に存在するようにする
- エンティティクラスと画面の間で、データの流れを確実に追跡できるようにする
- 代替コースが漏れていないか、そして見つけ出したすべての代替コースに対する振る舞いが記述されているか確認する
- 各ユースケースが、確実にユーザとシステムの間の対話の両側をカバーするようにする
- ロバストネス図の構文ルールを破っていないか確認する
- 技術者以外も含めてレビューを行う
- ユースケースが、オブジェクトモデルとGUIの用語で記述されていることを確認する
- ロバストネス図でシーケンス図上で表現するようなレベルの詳細を示そうとしていないか確認する
- よりよい予備設計のための「6つの簡単なステップ」に沿ってレビューを行う

よりよい予備設計のための6つの簡単なステップ
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 図がユースケース記述に合致していることかどうかを確認する
- 図がロバストネス分析の規則に従っているかどうかを確認する
- 図がユースケースの論理的な流れに注力しているかどうかを確認する
- ユースケースの動作に必要となるすべての代替コースが、図に示されているかどうかを確認する
- 図が「デザインパターン狂」になっていないかどうかを確認する
- 図が詳細設計に踏み込んでないかどうかを確認する

ロバストネス分析のルール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 名詞は、動詞とつなぐことができる（逆もまた同様）
- 名詞は、他の名詞とつなぐことはできない
- 動詞は、他の動詞とつなぐことができる
- コントローラは、システムの振る舞いを表すものであり、コントローラが記述から省かれるのは極めてまずい
- アクターがシステムに接続できるのは、バウンダリのみ
- コントローラを介在させることなく、名詞間の通信を行うことはできない

    - バウンダリとエンティティ
    - バウンダリとバウンダリ
    - エンティティとエンティティ


6. 分析/概念設計/アーキテクチャ : テクニカルアーキテクチャ
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- **機能**、 **データ**、 **システム** に対する個々のアーキテクチャを分離する
    - 配置モデル
        - ネットワーク、アプリケーションサーバ、それがどのように協調動作するか
        - システム トポロジー
        - サポートするWebブラウザなどのリスト
    - パッケージ / コンポーネント モデル
    - データモデル
- アーキテクチャを構築する理由を理解する
- 要求に基づいてアーキテクチャの目的を決定する
- **スケジューリング**、 **セキュリティ**、 **可能性** といった要素について考慮する
- **国際化**、 **地域化** について考慮する
- 困難な問題は、関係者全員に提示する
- 必要な答えが得られなければ、再度質問する
- **テスト容易性** について考慮する
- 連携しなければならない外部システムについて調査する
- アーキテクチャが正しいと思う勇気、プロジェクトの間を通じてアーキテクチャの決定を推進する強さを持つ
    - **アーキテクトは、自身がドキュメント化したアーキテクチャを伝え、全員に確実に理解させる必要がある**


7. 設計/実装 : 詳細設計 - シーケンス図
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 最大限の効果を得るために、 **なぜ** シーケンス図を書くのか理解する
- すべてのユースケースに対して、基本コースと代替コースの両方のシーケンス図を同じ図上に記述する
- シーケンス図の作成は、 **バウンダリクラス**、 **エンティティクラス**、 **アクター**、そしてロバストネス分析の結果を反映したユースケース記述から始める
- ユースケース記述が、シーケンス図上でやり取りされるメッセージと対応付けられるかどうかを確認する
- 活性区間に対する検討に時間をかけない
- メッセージを書くことによって、操作をクラスに割り当てる
    - **メッセージ/操作** をどのクラスの責務にするのか
- すべての操作が正しいクラスに割り当てられるように、操作の割り当てを行っているクラス図を繰り返しレビューする
- 実装を始める前に、シーケンス図上に描かれた設計をプレファクタリングする
- 詳細設計レビューを行う前に、静的モデルを整理する


8. 設計/実装 : 詳細設計レビュー
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- シーケンス図がユースケース記述に合致していることを確認する
- 個々のシーケンス図が基本コースと代替コースの両方をカバーしていることを確認する
- 操作が適切なクラスに割り当てられていることを確認する
- クラス図上のクラスに、適切な属性と操作が割り当てられていることを確認する
- 設計にパターンやその他の詳細な実装上の構造が適用されているのであれば、それらがシーケンス図にも反映されていることを確認する
- 機能要求および非機能要求がすべてカバーされていることを確かめるため、それらの要求をユースケースおよびクラス上で追跡する
- プログラマたちが設計を **しっかりとチェックした** かどうか、そしてその設計でしすシステムを構築でき、かつ期待通りに動作するかどうかを確認する
- すべての属性が正しく記述されており、操作の戻り値と引数リストが完全かつ正確であることを確認する
- クラスに対するコードの雛形を生成し、厳密に検査する
- リリースに対するテスト計画をレビューする


9. 設計/実装 : 実装
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 設計の結果そのまま実装する
- 設計のまずさが露呈したら、設計を変更する。そしてレビューする
- 通常のコードインスペクション(検証)を実施する
- フレームワークの設計理由を常に心に留めておく
- フレームワークの制約を、ビジネス上の制約よりも優先してはいけない
- コードが制御不能になりだしたら、コーディングを中断して設計に戻る
- 設計とコードを常に同期させる
- コードを記述している間は、単体テストに注力する
- コードにコメントを書きすぎない
- 基本コードだけでなく、代替コースの実装も忘れない


10. 設計/実装 : 単体テスト
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- バグの発見は勝利であり、敗北ではない
- さまざまなテストの方法や、いつどのような理由で利用するのか理解する
- 各ロバストネス図中のすべてのコントローラに対して、ひとつまたはそれ以上の単体テストを作成する
- リアルタイムシステムでは、テストケースの作成元として状態図中の要素を利用する
- 要求レベルでの検証作業（すべての要求が実現されるか）を行う
- 要求の検証では関係マトリクスを利用する
- 各ユースケースに対して、シナリオレベルの受入テストを行う
- シナリオテストでは、基本コース、代替コースすべてを対象とする
- テスティングフレームワークを利用する
- 単体テストの粒度を適切に揃える


11. 設計/実装 : コードレビューとモデルの更新
-----------------------------------------------------------

[やること]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[インプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[アウトプット]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[ガイドライン]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- レビューの準備を行い、ミーティング前にはすべての参加者にレビュー対象物を読ませておく
- ユースケースに基づいて、レビューで使う高いレベルでの項目リストを作成する
- 必要であれば、リスト内の各項目をより小さなチェックリストへの分割する
- さまざまなレベルでのコードのレビューを行う
- レビュー中にデータを収集して、定型的なチェックリストを蓄積する
- レビュワーにアクションアイテムのリストを送付しておく
- 誤りの検出に全力を尽くす
- モデリングツールとコードエディタの連携を可能とする、結合コード/モデルブラウザを利用する
- チェックリストとフォローアップ用のアクションリストを使って、「十分に形式化された状態」を維持する
- コードレビューだけでなく、モデルの更新のセッションでもあることを忘れない